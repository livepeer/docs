---
title: Monitor stream health
description: Learn how to monitor stream metrics on Livepeer
---

This guide provides instructions and information about using stream metrics to:

- Monitor any active stream for issues that may impact the quality of your
  stream
- Understand the metrics for operating a livestreaming or user generated content
  platform
- View health status of your livestream (API and Dashboard No-Code Option)

## Metrics with Source Segments Duration

The value of `sourceSegmentsDuration` returned is the duration in seconds of the
asset source processed by Livepeer Studio. On the parent stream object, this
value equates to the total amount of source video ingested by Livepeer Studio
all time. On the session object, this value is the length of the livestream
session (or the session recording).

### Request

Use the [get stream](/api-reference/stream/get) endpoint to retrieve a stream, or

<Tabs>
  <Tab title="Node.js">
    ```javascript
    import { Livepeer } from "livepeer";

    const apiKey = 'YOUR_API_KEY'; // Replace with your API key
    const streamId = 'STREAM_ID'; // Replace with the stream ID you want to retrieve

    const livepeer = new Livepeer(apiKey);

    livepeer
      .getStream(streamId)
      .then((response) => {
        console.log("Stream details:", response);
      })
      .catch((error) => {
        console.error("Error fetching stream details:", error);
      });
    ```

  </Tab>

  <Tab title="Python">
    ```python
    from livepeer import Livepeer

    # Initialize the Livepeer client with your API key
    api_key = "YOUR_API_KEY"
    livepeer = Livepeer(api_key)

    # Define the stream ID you want to retrieve
    stream_id = "STREAM_ID"

    try:
        # Get stream details by stream ID
        response = livepeer.get_stream(stream_id)
        print("Stream details:", response)
    except Exception as e:
        print("Error fetching stream details:", e)
    ```

  </Tab>

  <Tab title="Ruby">
    ```ruby
    require 'livepeer'

    # Initialize the Livepeer client with your API key
    api_key = 'YOUR_API_KEY'
    client = Livepeer::Client.new(api_key: api_key)

    # Define the stream ID you want to retrieve
    stream_id = 'STREAM_ID'

    begin
      # Get stream details by stream ID
      response = client.get_stream(stream_id)
      puts 'Stream details:', response
    rescue StandardError => e
      puts 'Error fetching stream details:', e.message
    end
    ```

  </Tab>

  <Tab title="PHP">
    ```php
    <?php

    require 'vendor/autoload.php';

    use Livepeer\Livepeer;
    use Livepeer\LivepeerException;

    // Initialize the Livepeer client with your API key
    $api_key = 'YOUR_API_KEY';
    $livepeer = new Livepeer($api_key);

    // Define the stream ID you want to retrieve
    $stream_id = 'STREAM_ID';

    try {
        // Get stream details by stream ID
        $response = $livepeer->getStream($stream_id);
        echo 'Stream details: ' . json_encode($response) . PHP_EOL;
    } catch (LivepeerException $e) {
        echo 'Error fetching stream details: ' . $e->getMessage() . PHP_EOL;
    }
    ```

  </Tab>

  <Tab title="Go">
    ```go
    package main

    import (
      "fmt"
      "os"

      "github.com/livepeer/go-sdk"
    )

    func main() {
      // Initialize the Livepeer client with your API key
      apiKey := "YOUR_API_KEY"
      client := livepeer.NewLivepeerClient(apiKey)

      // Define the stream ID you want to retrieve
      streamID := "STREAM_ID"

      // Get stream details by stream ID
      response, err := client.GetStream(streamID)
      if err != nil {
        fmt.Printf("Error fetching stream details: %v\n", err)
        os.Exit(1)
      }

      fmt.Printf("Stream details: %+v\n", response)
    }
    ```

  </Tab>
</Tabs>

**`GET /session/{id}` to retrieve a session object**

<Tabs>
  <Tab title="Node.js">
    ```javascript
    import { Livepeer } from "livepeer";

    const apiKey = 'YOUR_API_KEY'; // Replace with your API key
    const sessionId = 'SESSION_ID'; // Replace with the session ID you want to retrieve

    const livepeer = new Livepeer(apiKey);

    livepeer
      .getSession(sessionId)
      .then((response) => {
        console.log("Session details:", response);
      })
      .catch((error) => {
        console.error("Error fetching session details:", error);
      });
    ```

  </Tab>

  <Tab title="Python">
    ```python
    from livepeer import Livepeer

    # Initialize the Livepeer client with your API key
    api_key = "YOUR_API_KEY"
    livepeer = Livepeer(api_key)

    # Define the session ID you want to retrieve
    session_id = "SESSION_ID"

    try:
        # Get session details by session ID
        response = livepeer.get_session(session_id)
        print("Session details:", response)
    except Exception as e:
        print("Error fetching session details:", e)
    ```

  </Tab>

  <Tab title="Ruby">
    ```ruby
    require 'livepeer'

    # Initialize the Livepeer client with your API key
    api_key = 'YOUR_API_KEY'
    client = Livepeer::Client.new(api_key: api_key)

    # Define the session ID you want to retrieve
    session_id = 'SESSION_ID'

    begin
      # Get session details by session ID
      response = client.get_session(session_id)
      puts 'Session details:', response
    rescue StandardError => e
      puts 'Error fetching session details:', e.message
    end
    ```

  </Tab>

  <Tab title="PHP">
    ```php
    <?php

    require 'vendor/autoload.php';

    use Livepeer\Livepeer;
    use Livepeer\LivepeerException;

    // Initialize the Livepeer client with your API key
    $api_key = 'YOUR_API_KEY';
    $livepeer = new Livepeer($api_key);

    // Define the session ID you want to retrieve
    $session_id = 'SESSION_ID';

    try {
        // Get session details by session ID
        $response = $livepeer->getSession($session_id);
        echo 'Session details: ' . json_encode($response) . PHP_EOL;
    } catch (LivepeerException $e) {
        echo 'Error fetching session details: ' . $e->getMessage() . PHP_EOL;
    }
    ```

  </Tab>

  <Tab title="Go">
    ```go
    package main

    import (
      "fmt"
      "os"

      "github.com/livepeer/go-sdk"
    )

    func main() {
      // Initialize the Livepeer client with your API key
      apiKey := "YOUR_API_KEY"
      client := livepeer.NewLivepeerClient(apiKey)

      // Define the session ID you want to retrieve
      sessionID := "SESSION_ID"

      // Get session details by session ID
      response, err := client.GetSession(sessionID)
      if err != nil {
        fmt.Printf("Error fetching session details: %v\n", err)
        os.Exit(1)
      }

      fmt.Printf("Session details: %+v\n", response)
    }
    ```

  </Tab>
</Tabs>

### Response

- Returns a `200` response with the following object:

```json
{
  "name": "test_stream",
  "id": "ijkl61f3-95bd-4971-a7b1-4dcb5d39e78a",
  "createdAt": 1596081229373,
  "streamKey": "abcd-uimq-jtgy-x98v",
  "playbackId": "efghb2mxupongp5k",
  "isActive": "true",
  "lastSeen": 1596119750455,
  "sourceSegments": 1360,
  "transcodedSegments": 5480,
  "sourceSegmentsDuration": 2630.53200000000004,
  "transcodedSegmentsDuration": 10620.1280000000004
  // other asset object keys, like profiles and parentId
}
```

## Global Health Status

- `Healthy` indicates that all the Health Checks are in a `Healthy` state.
- `Unhealthy` indicates that one or more of the Health Checks are in an
  `Unhealthy` state
- `Idle` indicates that the stream is not currently active

## Health Checks

- **_Transcoding_** — A `Healthy` status indicates that video transcoding is
  occurring, and the multiple profiles of your stream are available for
  playback. An `Unhealthy` status indicates that we have failed to generate the
  profiles , so only the original video will be available. Check the event log
  below for any actionable errors, or check the
  [Status page](https://livepeer.statuspage.io/) for platform-wide issues.
- **_Real-time —_** This indicates whether our system transcoded the stream
  faster than in real-time. In other words, if the video transcodes, latency is
  lower than the video duration. Unconventional configurations may cause an
  `Unhealthy` status.
- **_Multistreaming —_** This health check indicates whether all configured
  `Multistream Targets` are connected. If no targets exist, this will appear
  blank and not be considered for the global health state. If this shows up as
  `Unhealthy`, you can also check the status of the individual
  `Multistream Targets` in the `Overivew` tab, where the targets can be either
  `Idle`, `Pending`, `Online'or' Offline`:
  - An `Idle` status indicates that the stream is not currently active, so
    neither is multistreaming.
  - A `Pending` status indicates that our system tries connecting to the
    respective `Multistream Target`.
  - An `Online` status indicates that the `Multistream Target` is successfully
    connected.
  - An `Offline` status means that we've received an error when trying to
    connect to the target. To try again, check the ingest URL and stream key of
    your destination service, re-configure your `Multistream Target` and restart
    your stream.

## Logs

Logs will surface informational alerts (ex., stream has started/stopped,
multistream destinations have connected/disconnected) or any fatal errors from
the transcoding process. Here is an example of a fatal error:

```bash
Transcode error from ewr-prod-livepeer-orchestrator-0 for segment 0:
**Unsupported input pixel format**
```

If you run into this or any similar errors, check the configuration in your
streaming software (e.g., OBS) and restart the stream.

## Session Ingest Rate

Session ingest rate tells you the bitrate of the video received by Livepeer
ingest servers, updated every 10 seconds. A high bitrate is suggestive that
streams into the Livepeer system are high quality, your encoder is working
correctly, and your internet connection is good. A fluctuating or low bitrate
may suggest that your encoder is misconfigured or that the streamer internet
connection isn't as strong as it should be to deliver high-quality streams to
your viewers.

## Monitoring Stream Health Using The Dashboard

In the dashboard, there will be a `health` tab on the right side:

<Frame>
  ![image](https://user-images.githubusercontent.com/79172645/135450248-bf3edea4-e666-4927-8114-f972cd2879fe.png)
</Frame>
During any Active stream, components on this page will display a variety of health
indicators.
<Frame>

![image](https://user-images.githubusercontent.com/79172645/135450296-168bd797-fafb-4371-af8a-86b346bbaa18.png)

</Frame>
<br />
<Frame>
  ![image](https://user-images.githubusercontent.com/79172645/135450340-4abed968-df77-473d-b926-88c11b5799d2.png)
</Frame>

At the bottom of the page, a chart will show the ingest rate of a livestream:

<Frame>
  ![image](https://user-images.githubusercontent.com/79172645/135467197-08ec63ab-4c44-4cad-a0d5-95a76b80e5c5.png)
</Frame>

## Monitor Stream Health Using The API

The health information about a stream can also be queried using a separate
Stream Health API resides on a different root path `/data`. To use it, you need
to include the same API key as the one used for the regular API. The API
consists of the following endpoints:

- Health Status (`/data/stream/{streamId}/health`): Grabs the latest health
  status info about a given stream, referenced by its Stream ID. This API powers
  the dashboard health checks and multistream status.
- Events (`/data/stream/{streamId}/events`): Provides direct access to the
  low-level events sent by Livepeer video-processing services. It also allows
  subscribing via SSE to receive new events and is useful for debugging. This
  API powers the log feed in the dashboard.

Now let's go into more detail about each of the mentioned API endpoints.

## Health Status

The stream ID is the same one as used in the Livestream API.

`GET livepeer.studio/data/stream/{id}/health`

<Tabs>
  <Tab title="Node.js">
    ```javascript
    import { Livepeer } from "livepeer";

    const apiKey = 'YOUR_API_KEY'; // Replace with your API key
    const streamId = 'STREAM_ID'; // Replace with the stream ID for which you want to check health

    const livepeer = new Livepeer(apiKey);

    livepeer
      .getStreamHealth(streamId)
      .then((response) => {
        console.log("Stream health:", response);
      })
      .catch((error) => {
        console.error("Error fetching stream health:", error);
      });
    ```

  </Tab>

  <Tab title="Python">
    ```python
    from livepeer import Livepeer

    # Initialize the Livepeer client with your API key
    api_key = "YOUR_API_KEY"
    livepeer = Livepeer(api_key)

    # Define the stream ID for which you want to check health
    stream_id = "STREAM_ID"

    try:
        # Get stream health by stream ID
        response = livepeer.get_stream_health(stream_id)
        print("Stream health:", response)
    except Exception as e:
        print("Error fetching stream health:", e)
    ```

  </Tab>

  <Tab title="Ruby">
    ```ruby
    require 'livepeer'

    # Initialize the Livepeer client with your API key
    api_key = 'YOUR_API_KEY'
    client = Livepeer::Client.new(api_key: api_key)

    # Define the stream ID for which you want to check health
    stream_id = 'STREAM_ID'

    begin
      # Get stream health by stream ID
      response = client.get_stream_health(stream_id)
      puts 'Stream health:', response
    rescue StandardError => e
      puts 'Error fetching stream health:', e.message
    end
    ```

  </Tab>

  <Tab title="PHP">
    ```php
    <?php

    require 'vendor/autoload.php';

    use Livepeer\Livepeer;
    use Livepeer\LivepeerException;

    // Initialize the Livepeer client with your API key
    $api_key = 'YOUR_API_KEY';
    $livepeer = new Livepeer($api_key);

    // Define the stream ID for which you want to check health
    $stream_id = 'STREAM_ID';

    try {
        // Get stream health by stream ID
        $response = $livepeer->getStreamHealth($stream_id);
        echo 'Stream health: ' . json_encode($response) . PHP_EOL;
    } catch (LivepeerException $e) {
        echo 'Error fetching stream health: ' . $e->getMessage() . PHP_EOL;
    }
    ```

  </Tab>

  <Tab title="Go">
    ```go
    package main

    import (
      "fmt"
      "os"

      "github.com/livepeer/go-sdk"
    )

    func main() {
      // Initialize the Livepeer client with your API key
      apiKey := "YOUR_API_KEY"
      client := livepeer.NewLivepeerClient(apiKey)

      // Define the stream ID for which you want to check health
      streamID := "STREAM_ID"

      // Get stream health by stream ID
      response, err := client.GetStreamHealth(streamID)
      if err != nil {
        fmt.Printf("Error fetching stream health: %v\n", err)
        os.Exit(1)
      }

      fmt.Printf("Stream health: %+v\n", response)
    }
    ```

  </Tab>
</Tabs>

### Response

Returns an object with a `200 OK` response

```json
{
  "id": "{id}",
  "healthy": {
    "status": true,
    "frequency": { "1m": 1, "10m": 0.9655, "60m": 0.9655 },
    "lastProbeTime": 1635993921603,
    "lastTransitionsTime": 1635993751824
  },
  "conditions": [
    {
      "type": "Active",
      "status": true,
      "extraData": {
        "nodeId": "prod-mist-blue-server-1",
        "region": "lon"
      },
      "frequency": { "1m": 1, "10m": 1, "60m": 1 },
      "lastProbeTime": 1635993739354,
      "lastTransitionsTime": 1635993739354
    },
    {
      "type": "Transcoding",
      "status": true,
      "frequency": { "1m": 1, "10m": 1, "60m": 1 },
      "lastProbeTime": 1635993920641,
      "lastTransitionsTime": 1635993751824
    },
    {
      "type": "TranscodeRealTime",
      "status": true,
      "frequency": { "1m": 1, "10m": 1, "60m": 1 },
      "lastProbeTime": 1635993920641,
      "lastTransitionsTime": 1635993751824
    },
    {
      "type": "TranscodeNoErrors",
      "status": true,
      "frequency": { "1m": 1, "10m": 1, "60m": 1 },
      "lastProbeTime": 1635993920641,
      "lastTransitionsTime": 1635993751824
    },
    {
      "type": "Multistreaming",
      "status": null,
      "lastProbeTime": null,
      "lastTransitionsTime": null
    }
  ],
  "metrics": {
    "MediaTimeMillis": [
      {
        "name": "MediaTimeMillis",
        "dimensions": { "nodeId": "prod-mist-blue-server-1" },
        "last": [1635993921603, 182528]
      }
    ],
    "TranscodeRealtimeRatio": [
      {
        "name": "TranscodeRealtimeRatio",
        "dimensions": {
          "nodeId": "prod-livepeer-broadcaster-6emu-97d8bf496-7zh9f"
        },
        "last": [1635993920641, 3.088169642857143]
      }
    ]
  }
}
```

In the above response payload:

- All `timestamps` are represented in milliseconds since the Unix epoch, which
  is the default representation of timestamps across all the Livepeer API.
- The `healthy` top-level `condition` is a computed state based on some specific
  stream conditions. As of writing this doc, a stream is `healthy` if it's both
  `Active`, `Transcoding` in realtime (`TranscodeRealTime`), and if multistream
  targets are configured, they are also healthy (`Multistreaming`).
- The `conditions` array contains more specific information about the stream
  health state, with the `type` field specifying what the condition means.
- More generally, a `Condition` represents a specific state of the stream
  health.
  - The `status` field represents the value of the last reading for that
    condition, and the `lastProbeTime` specified when that was.
  - The `lastTransitionsTime` and the `frequency` fields provide some insight
    into how it's changing over time.
  - The `lastTransitionTime` is the timestamp of the last time where the
    condition status changed, and;
  - The `frequency` is the ratio of successful probes (`status: true`) in the
    specified time ranges preceding `lastProbeTime`.
- The `metrics` are still an experimental API and are not recommended for
  production systems. But the `last` field is a tuple containing the `timestamp`
  and the `value` of the last reading for that metric.

## Events

### Request

The stream ID is the same one used in the Livestream API.

`GET livepeer.studio/data/stream/{id}/events`

<Tabs>
  <Tab title="Node.js">
    ```javascript
    import { Livepeer } from "livepeer";

    const apiKey = 'YOUR_API_KEY'; // Replace with your API key
    const streamId = 'STREAM_ID'; // Replace with the stream ID for which you want to fetch events

    const livepeer = new Livepeer(apiKey);

    livepeer
      .getStreamEvents(streamId)
      .then((response) => {
        console.log("Stream events:", response);
      })
      .catch((error) => {
        console.error("Error fetching stream events:", error);
      });
    ```

  </Tab>

  <Tab title="Python">
    ```python
    from livepeer import Livepeer

    # Initialize the Livepeer client with your API key
    api_key = "YOUR_API_KEY"
    livepeer = Livepeer(api_key)

    # Define the stream ID for which you want to fetch events
    stream_id = "STREAM_ID"

    try:
        # Get stream events by stream ID
        response = livepeer.get_stream_events(stream_id)
        print("Stream events:", response)
    except Exception as e:
        print("Error fetching stream events:", e)
    ```

  </Tab>

  <Tab title="Ruby">
    ```ruby
    require 'livepeer'

    # Initialize the Livepeer client with your API key
    api_key = 'YOUR_API_KEY'
    client = Livepeer::Client.new(api_key: api_key)

    # Define the stream ID for which you want to fetch events
    stream_id = 'STREAM_ID'

    begin
      # Get stream events by stream ID
      response = client.get_stream_events(stream_id)
      puts 'Stream events:', response
    rescue StandardError => e
      puts 'Error fetching stream events:', e.message
    end
    ```

  </Tab>

  <Tab title="PHP">
    ```php
    <?php

    require 'vendor/autoload.php';

    use Livepeer\Livepeer;
    use Livepeer\LivepeerException;

    // Initialize the Livepeer client with your API key
    $api_key = 'YOUR_API_KEY';
    $livepeer = new Livepeer($api_key);

    // Define the stream ID for which you want to fetch events
    $stream_id = 'STREAM_ID';

    try {
        // Get stream events by stream ID
        $response = $livepeer->getStreamEvents($stream_id);
        echo 'Stream events: ' . json_encode($response) . PHP_EOL;
    } catch (LivepeerException $e) {
        echo 'Error fetching stream events: ' . $e->getMessage() . PHP_EOL;
    }
    ```

  </Tab>

  <Tab title="Go">
    ```go
    package main

    import (
      "fmt"
      "os"

      "github.com/livepeer/go-sdk"
    )

    func main() {
      // Initialize the Livepeer client with your API key
      apiKey := "YOUR_API_KEY"
      client := livepeer.NewLivepeerClient(apiKey)

      // Define the stream ID for which you want to fetch events
      streamID := "STREAM_ID"

      // Get stream events by stream ID
      response, err := client.GetStreamEvents(streamID)
      if err != nil {
        fmt.Printf("Error fetching stream events: %v\n", err)
        os.Exit(1)
      }

      fmt.Printf("Stream events: %+v\n", response)
    }
    ```

  </Tab>
</Tabs>

### Response

Returns an object with a `200 OK` response

```
retry: 10000

id: b6e0d6a4-0718-4db4-b2ec-31bb23a9fde0
event: lp_event
data: {"type":"media_server_metrics","id":"b6e0d6a4-0718-4db4-b2ec-31bb23a9fde0","timestamp":1635994871604,"streamId":"{id}","nodeId":"prod-mist-blue-server-1","region":"lon","stats":{"mediaTimeMs":1132566},"multistream":[]}

id: 7a0e6f9e-baa1-42c4-a92f-4dfa2f50ac05
event: lp_event
data: {"type":"transcode","id":"7a0e6f9e-baa1-42c4-a92f-4dfa2f50ac05","timestamp":1635994875678,"streamId":"{id}","nodeId":"prod-livepeer-broadcaster-6emu-97d8bf496-7zh9f","segment":{"name":"","seqNo":292,"duration":8.334,"byteSize":2270100},"startTime":1635994874469,"latencyMs":1209,"success":true,"attempts":[{"orchestrator":{"address":"0x1cd98ad89a7d143847f62d2249e4005d09e10648","transcodeUri":"https://vno2-prod-livepeer-orchestrator-7.livepeer.studio:443"},"latencyMs":1209,"error":null}]}

id: fd782a49-4986-4b3c-b3b4-9088ae76c152
event: lp_event
data:
{"type":"media_server_metrics","id":"fd782a49-4986-4b3c-b3b4-9088ae76c152","timestamp":1635994881604,"streamId":"{id}","nodeId":"prod-mist-blue-server-1","region":"lon","stats":{"mediaTimeMs":1142550},"multistream":[]}
...
```

The `/events` API response implements the
[Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
protocol using any SSE client. On JavaScript, we recommend using the
[`eventsource`](https://www.npmjs.com/package/eventsource) NPM package to be
able to add an `Authorization` header to the API request.

The individual events sent over the SSE stream are all JSON objects and are
precisely the same low-level objects as published by the services running in the
Livepeer infrastructure. Some fields are always present, specifically:

- `type`: the unique type of the event, which defines the structure of the rest
  of the JSON object.
- `id`: a unique identifier for the event, which SSE clients automatically use
  to recover a connection without losing events.
- `timestamp`: the timestamp of the event in milliseconds since the Unix epoch.

You can also get historical events within a time range by specifying the `from`
and `to` query parameters with Unix millis timestamps. For example:

- `/data/stream/{id}/events?from=1635437394000` to get all events since
  `Oct 28 16:09:54Z 2021` (exclusively) and stay connected for live events.
- `/data/stream/{id}/events?from=1635437394000&to=1635447394000` to get all
  events between `Oct 28 16:09:54Z 2021` (exclusively) and
  `Oct 28 18:56:34Z 2021` (inclusively).

Finally, we recommend using the events API primarily for debugging purposes, for
example, to get all available information about a livestream to find any
issues. The specific events that are published and
[their respective schemas](https://github.com/livepeer/livepeer-data/tree/main/pkg/data)
will keep evolving, so they are still subject to changes.
