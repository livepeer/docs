---
title: 'Upload encrypted files to Livepeer'
description: 'Learn how to upload and playback an encrypted video asset'
---

import { Callout } from 'nextra-theme-docs';

# Encrypted VOD with Livepeer

Livepeer enables you to upload encrypted video content or import it from decentralized storages. It creates a playback URL that can be covered by playback policies and access control.

## Step 1: Generate an encryption key

First, we generate a 256-bit encryption key to encrypt the file. 

```js
// Generate a random 256-bit key
const key = await window.crypto.subtle.generateKey(
	{
		name: "AES-CBC",
		length: 256,
	},
	true,
	["encrypt", "decrypt"]
);

// Export the key as raw data
const keyData = await window.crypto.subtle.exportKey("raw", key);

// Encode the key in Base64
const keyBase64 = btoa(String.fromCharCode(...new Uint8Array(keyData)));
```

## Step 2: Encrypt your video using the encryption key

To encrypt a video file with the key we just generated, we follow these steps:

1. Generate a random 128-bit initialization vector (IV).
2. Pad the data using PKCS#7 padding.
3. Encrypt the data using AES-CBC.

```js
const iv = window.crypto.getRandomValues(new Uint8Array(16));

const encrypted = await window.crypto.subtle.encrypt(
	{
		name: "AES-CBC",
		iv: iv,
	},
	key, // from generateKey or importKey above
	arrayBuffer // ArrayBuffer of data you want to encrypt
);

// Concatenate IV and encrypted file into a new ArrayBuffer
const resultBuffer = new ArrayBuffer(iv.length + encrypted.byteLength);
new Uint8Array(resultBuffer).set(new Uint8Array(iv), 0);
new Uint8Array(resultBuffer).set(new Uint8Array(encrypted), iv.length);

const blob = new Blob([resultBuffer], { type: "application/octet-stream" });
```
<Callout>
  Currently Livepeer supports only video content encrypted using AES-CBC with PKCS#7 padding.
</Callout>

## Step 3: Retrieve the Livepeer Public Key

After obtaining an encryption key and encrypting a video file with it, the next step is to retrieve the Livepeer Public Key. This key will be used to encrypt our encryption key, which can then be shared with Livepeer when creating a video asset.

```js
// Fetch the public key from Livepeer
const publicKeyResponse = await fetch('https://livepeer.monster/api/access-control/public-key', {
	headers: {
		'Authorization': 'Bearer XXXX-XXXXXX-XXXXXXX-XXXX',
	},
});

const publicKeyData = await publicKeyResponse.json();
const publicKey = publicKeyData.public_key;
```

## Step 4: Encrypt the encryption key

Now, we can use asymmetric encryption with the Livepeer Public Key to encrypt our Encryption Key. The resulting data is then encoded in base64 before being sent to Livepeer along with the video file.

<Callout>
	The Web Cryptography API built into modern browsers does not directly support PEM or PKCS#1 formatted keys. It only supports the SPKI format for public keys and the PKCS8 format for private keys. This is an example of a server-side Golang handler receiving the encryptionKey and the publicKey.
</Callout>

```go filename="main.go"
    encryptionKey := // Encryption key
	pubKey := // Livepeer public key

	// Load the public key
	data, err := base64.StdEncoding.DecodeString(pubKey)
	if err != nil {
		log.Fatalf("Error decoding public key: %v", err)
	}

	block, _ := pem.Decode(data)
	if block == nil {
		log.Fatalf("Failed to parse PEM block containing the key")
	}

	pub, err := x509.ParsePKCS1PublicKey(block.Bytes)
	if err != nil {
		log.Fatalf("Error parsing public key: %v", err)
	}

	key, err := base64.StdEncoding.DecodeString(string(encryptionKey))
	if err != nil {
		http.Error(w, "Invalid base64  key", http.StatusBadRequest)
		return
	}

	// Encrypt the key
	encryptedKey, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, pubKey, key, nil)
	if err != nil {
		http.Error(w, "Error encrypting key", http.StatusInternalServerError)
		return
	}

	// Return the encrypted key
	json.NewEncoder(w).Encode(EncryptedKey{Key: base64.StdEncoding.EncodeToString(encryptedKey)})
```

## Step 5: Upload the video file or Import it from decentralized storages

We're all set to upload the video file. There are two ways to do this:

- Request a direct upload and add the `encryptedKey` to the payload under the `encryption` object.
- Import it from a decentralized or external storage and add the `encryptedKey` to the payload under the `encryption` object.

When calling the `import` API:
```json
{
    "url":"ipfs://QmaxiZYQhdDQrHrS3rnPHfvdJx8XfuVLv2nGv4y8cdVUnM",
    "name":"import_from_ipfs",
    "encryption":{
        "encryptedKey":"<YOUR_BASE_64_ENCODED_ENCRYPTED_ENCRYPTION_KEY>"
    }
}
```

When calling the `request-upload` API:
```json
{
    "name": "request_direct_upload",
    "encryption":{
        "encryptedKey":"<YOUR_BASE_64_ENCODED_ENCRYPTED_ENCRYPTION_KEY>"
    }
}
```